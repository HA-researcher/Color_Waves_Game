<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>彩りの機織り (Color Weave)</title>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --main-color: #ffffff;
            --accent-color: #6c5ce7;
            --text-color: #333333;
            --border-color: #e0e0e0;
            --shadow-color: rgba(0, 0, 0, 0.1);
            
            --color-red: #e74c3c;
            --color-green: #2ecc71;
            --color-blue: #3498db;
            --color-yellow: #f1c40f;
            --color-cyan: #1abc9c;
            --color-magenta: #9b59b6;
            --color-white: #ffffff;
            --color-black: #34495e;
            --color-neutral: #bdc3c7; /* Color for the colorless thread */
        }

        body {
            font-family: 'Helvetica Neue', 'Arial', 'Hiragino Kaku Gothic ProN', 'Hiragino Sans', 'Meiryo', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .hidden {
            display: none !important;
        }

        .game-container {
            width: 100%;
            max-width: 800px;
            background-color: var(--main-color);
            border-radius: 16px;
            box-shadow: 0 8px 32px var(--shadow-color);
            padding: 20px;
            box-sizing: border-box;
            text-align: center;
            transition: all 0.3s ease;
        }

        /* --- Screens --- */
        #title-screen h1 {
            font-size: 3rem;
            color: var(--accent-color);
            margin-bottom: 10px;
            font-weight: 700;
        }

        #title-screen p {
            font-size: 1.2rem;
            color: #777;
            margin-bottom: 40px;
        }

        .btn {
            padding: 12px 28px;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            background-color: var(--accent-color);
            color: white;
            box-shadow: 0 4px 16px rgba(108, 92, 231, 0.3);
        }
        .btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(108, 92, 231, 0.4);
        }
        
        .btn-secondary {
            background-color: #f0f0f0;
            color: var(--text-color);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        }
        
        .btn-secondary:hover:not(:disabled) {
             background-color: #e0e0e0;
             box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }

        #stage-select-screen h2, #game-screen h2 {
            font-size: 2rem;
            margin-bottom: 20px;
        }

        .stage-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .stage-btn {
            width: 100%;
            aspect-ratio: 1 / 1;
            font-size: 1.5rem;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background-color: white;
            position: relative;
            overflow: hidden;
        }

        .stage-btn.cleared {
            background-color: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }
        
        .stage-btn.cleared::after {
            content: '✔';
            position: absolute;
            top: 5px;
            right: 8px;
            font-size: 1rem;
            color: #155724;
        }
        
        .settings-icon {
            position: absolute;
            top: 25px;
            right: 25px;
            font-size: 1.5rem;
            cursor: pointer;
            z-index: 100;
        }

        /* --- Game Screen --- */
        #game-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .game-main-area {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 20px;
            width: 100%;
            flex-wrap: wrap;
        }
        
        .game-panel {
            text-align: center;
        }
        .game-panel h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .grid-container {
            display: grid;
            border: 2px solid #ccc;
            position: relative;
            background-color: #f9f9f9;
        }

        .grid-cell {
            aspect-ratio: 1 / 1;
            background-color: transparent;
        }
        
        .threads-overlay, .highlight-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .highlight-row {
            position: absolute;
            width: 100%;
            background-color: rgba(108, 92, 231, 0.2);
            pointer-events: none;
            transition: top 0.3s ease;
        }
        
        .thread {
            position: absolute;
        }
        
        .thread.vertical { width: 4px; height: 100%; transform: translateX(-50%); }
        .thread.horizontal { height: 4px; width: 100%; transform: translateY(-50%); }
        
        .thread.r { background-color: var(--color-red); }
        .thread.g { background-color: var(--color-green); }
        .thread.b { background-color: var(--color-blue); }
        .thread.n { background-color: var(--color-neutral); }

        #thread-selector {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
        }
        
        .thread-group {
            display:flex;
            gap: 10px;
            align-items: center;
            transition: opacity 0.3s;
        }
        
        .thread-group.disabled {
            opacity: 0.4;
            pointer-events: none;
        }
        
        .thread-label {
            width: 30px;
            font-weight: bold;
        }

        .draggable-thread {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            cursor: grab;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 2px solid var(--border-color);
            background-color: white;
            position: relative;
        }
        .draggable-thread:active {
            cursor: grabbing;
        }

        .draggable-thread-inner {
            position: absolute;
            background-color: #333;
        }
        .draggable-thread.vertical .draggable-thread-inner {
            width: 6px;
            height: 70%;
        }
        .draggable-thread.horizontal .draggable-thread-inner {
            height: 6px;
            width: 70%;
        }
        .draggable-thread.r .draggable-thread-inner { background-color: var(--color-red); }
        .draggable-thread.g .draggable-thread-inner { background-color: var(--color-green); }
        .draggable-thread.b .draggable-thread-inner { background-color: var(--color-blue); }
        .draggable-thread.n .draggable-thread-inner { background-color: var(--color-neutral); }

        .game-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
            width: 100%;
            justify-content: center;
        }

        /* --- Modal & Tutorial --- */
        .modal-overlay, .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content, .tutorial-box {
            background-color: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            text-align: center;
            width: 90%;
            max-width: 400px;
        }
        .modal-content h3, .tutorial-box h3 { margin-top: 0; font-size: 1.5rem; }
        .modal-content p, .tutorial-box p { margin-bottom: 25px; line-height: 1.6; }
        .modal-actions { display: flex; justify-content: center; gap: 15px; }
        #close-tutorial { margin-top: 15px; }
        .tutorial-overlay { z-index: 2000; }

        /* Responsive */
        @media (max-width: 768px) {
            body { padding: 10px; }
            .game-container { padding: 15px; }
            #title-screen h1 { font-size: 2.5rem; }
            
            .game-main-area {
                flex-direction: column;
                align-items: center;
            }
            #thread-selector {
                order: -1;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
            }
            .thread-group { flex-direction: column; }
        }
    </style>
</head>
<body>

    <div class="game-container">
        <div id="settings-icon" class="settings-icon hidden">⚙️</div>
        <div id="title-screen">
            <h1>彩りの機織り</h1>
            <p>Color Weave</p>
            <button id="start-game-btn" class="btn">ゲームスタート</button>
        </div>
        <div id="stage-select-screen" class="hidden">
            <h2>ステージ選択</h2>
            <div id="stage-grid" class="stage-grid"></div>
        </div>
        <div id="game-screen" class="hidden">
            <h2 id="stage-title">Stage 1</h2>
            <div class="game-main-area">
                <div class="game-panel">
                    <h3>お手本</h3>
                    <div id="goal-grid" class="grid-container"></div>
                </div>
                <div class="game-panel">
                    <h3>織り機</h3>
                    <div id="player-grid" class="grid-container"></div>
                </div>
                <div class="game-panel">
                    <h3>糸</h3>
                    <div id="thread-selector">
                        <div id="vertical-thread-group" class="thread-group">
                            <span class="thread-label">縦</span>
                            <div class="draggable-thread vertical r" draggable="true" data-color="r" data-orientation="vertical"><div class="draggable-thread-inner"></div></div>
                            <div class="draggable-thread vertical g" draggable="true" data-color="g" data-orientation="vertical"><div class="draggable-thread-inner"></div></div>
                            <div class="draggable-thread vertical b" draggable="true" data-color="b" data-orientation="vertical"><div class="draggable-thread-inner"></div></div>
                            <div class="draggable-thread vertical n" draggable="true" data-color="n" data-orientation="vertical"><div class="draggable-thread-inner"></div></div>
                        </div>
                         <div id="horizontal-thread-group" class="thread-group">
                            <span class="thread-label">横</span>
                            <div class="draggable-thread horizontal r" draggable="true" data-color="r" data-orientation="horizontal"><div class="draggable-thread-inner"></div></div>
                            <div class="draggable-thread horizontal g" draggable="true" data-color="g" data-orientation="horizontal"><div class="draggable-thread-inner"></div></div>
                            <div class="draggable-thread horizontal b" draggable="true" data-color="b" data-orientation="horizontal"><div class="draggable-thread-inner"></div></div>
                            <div class="draggable-thread horizontal n" draggable="true" data-color="n" data-orientation="horizontal"><div class="draggable-thread-inner"></div></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="game-controls">
                <button id="confirm-verticals-btn" class="btn">縦糸を確定</button>
                <button id="hint-btn" class="btn btn-secondary">ヒント</button>
                <button id="reset-btn" class="btn btn-secondary">リセット</button>
                <button id="back-to-select-btn" class="btn btn-secondary">ステージ選択へ</button>
            </div>
        </div>
    </div>
    
    <div id="modal-overlay" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 id="modal-title"></h3>
            <p id="modal-message"></p>
            <div class="modal-actions">
                <button id="modal-confirm" class="btn"></button>
                <button id="modal-cancel" class="btn btn-secondary">キャンセル</button>
            </div>
        </div>
    </div>
    
    <div id="tutorial-overlay" class="tutorial-overlay hidden">
        <div class="tutorial-box">
             <h3 id="tutorial-title"></h3>
             <p id="tutorial-message"></p>
             <button id="close-tutorial" class="btn">わかった</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const titleScreen = document.getElementById('title-screen'),
                  stageSelectScreen = document.getElementById('stage-select-screen'),
                  gameScreen = document.getElementById('game-screen'),
                  screens = [titleScreen, stageSelectScreen, gameScreen],
                  startGameBtn = document.getElementById('start-game-btn'),
                  stageGrid = document.getElementById('stage-grid'),
                  backToSelectBtn = document.getElementById('back-to-select-btn'),
                  resetBtn = document.getElementById('reset-btn'),
                  stageTitle = document.getElementById('stage-title'),
                  goalGrid = document.getElementById('goal-grid'),
                  playerGrid = document.getElementById('player-grid'),
                  threadSelector = document.getElementById('thread-selector'),
                  verticalThreadGroup = document.getElementById('vertical-thread-group'),
                  horizontalThreadGroup = document.getElementById('horizontal-thread-group'),
                  settingsIcon = document.getElementById('settings-icon'),
                  modalOverlay = document.getElementById('modal-overlay'),
                  modalTitle = document.getElementById('modal-title'),
                  modalMessage = document.getElementById('modal-message'),
                  modalConfirm = document.getElementById('modal-confirm'),
                  modalCancel = document.getElementById('modal-cancel'),
                  tutorialOverlay = document.getElementById('tutorial-overlay'),
                  tutorialTitle = document.getElementById('tutorial-title'),
                  tutorialMessage = document.getElementById('tutorial-message'),
                  closeTutorialBtn = document.getElementById('close-tutorial'),
                  hintBtn = document.getElementById('hint-btn'),
                  confirmVerticalsBtn = document.getElementById('confirm-verticals-btn');

            // --- Game Data ---
            let STAGES = [
                // All stages now include the neutral 'n' thread and are designed for the new gameplay flow.
                // Beginner (3x3)
                { size: 3, solution: {v:['r','n','b'],h:['g',null,null]} },
                { size: 3, solution: {v:['r','g','b'],h:['n','n',null]} },
                { size: 3, solution: {v:['n','b','n'],h:['r','g','r']} },
                { size: 3, solution: {v:['b','g','n'],h:[null,'n','b']} },
                { size: 3, solution: {v:['r','n','r'],h:['n','b','n']} },
                // Intermediate (4x4)
                { size: 4, solution: {v:['r','g','b','n'],h:['n','g','b',null]} },
                { size: 4, solution: {v:['b','n','g','b'],h:[null,'g','n','g']} },
                { size: 4, solution: {v:['r','r','n',null],h:['g','g','b','b']} },
                { size: 4, solution: {v:['r','g','g','r'],h:['n','b','b','n']} },
                { size: 4, solution: {v:['g','n','g','n'],h:['b','r','b','r']} },
                // Advanced (4x4 & 5x5)
                { size: 4, solution: {v:['r','b','r','b'],h:['n','r','r','n']} },
                { size: 4, solution: {v:['r','n','g','g'],h:['b','b','n','r']} },
                { size: 5, solution: {v:['r','g','n','b','r'],h:['n','n',null,null,null]} },
                { size: 5, solution: {v:['b','g','n','g','b'],h:[null,'g','n','g',null]} },
                { size: 5, solution: {v:['r','n','g','g','n'],h:['n','r','n','b','b']} },
                // Expert (5x5)
                { size: 5, solution: {v:['n','b','b','b','n'],h:['g','n','n','n','g']} },
                { size: 5, solution: {v:['r','g','b','g','r'],h:['n','g','r','g','n']} },
                { size: 5, solution: {v:['r','n',null,'n','r'], h:['g','b','n','b','g']} },
                { size: 5, solution: {v:['r','g','b','g','r'], h:['b','n','r','n','b']} },
                { size: 5, solution: {v:['r','g','n','g','r'],h:['r','n','b','n','r']} }
            ];
            
            const COLOR_MAP = { r: 'var(--color-red)', g: 'var(--color-green)', b: 'var(--color-blue)', y: 'var(--color-yellow)', c: 'var(--color-cyan)', m: 'var(--color-magenta)', n: 'var(--color-neutral)', black: 'var(--color-black)' };

            // --- Game State ---
            let currentStage = 0, playerThreads = { vertical: [], horizontal: [] }, draggedThread = null, clearedStages = [], gamePhase = 'vertical', currentWeavingRow = 0;

            // --- Functions ---
            const mixColors = (vColor, hColor) => {
                if (!vColor && !hColor) return 'black';
                if (vColor === 'n' && hColor === 'n') return 'black';
                if (vColor === 'n') return hColor || 'black';
                if (hColor === 'n') return vColor || 'black';
                if (!vColor) return hColor;
                if (!hColor) return vColor;
                if (vColor === hColor) return vColor;
                const colors = new Set([vColor, hColor]);
                if (colors.has('r') && colors.has('g')) return 'y';
                if (colors.has('g') && colors.has('b')) return 'c';
                if (colors.has('b') && colors.has('r')) return 'm';
                return 'black';
            };

            const generateGoalFromSolution = (solution, size) => {
                const goal = [];
                for (let row = 0; row < size; row++) {
                    for (let col = 0; col < size; col++) {
                        goal.push(mixColors(solution.v[col], solution.h[row]));
                    }
                }
                return goal;
            };

            const showScreen = (screenToShow) => {
                screens.forEach(s => s.classList.add('hidden'));
                screenToShow.classList.remove('hidden');
                settingsIcon.classList.toggle('hidden', screenToShow === titleScreen);
            };
            
            const goToStageSelectScreen = () => { buildStageSelect(); showScreen(stageSelectScreen); };
            const goToGameScreen = (stageId) => { loadStage(stageId); showScreen(gameScreen); };

            const saveProgress = () => localStorage.setItem('colorWeaveProgress', JSON.stringify(Array.from(clearedStages)));
            const loadProgress = () => clearedStages = new Set(JSON.parse(localStorage.getItem('colorWeaveProgress') || '[]'));
            const resetProgress = () => { clearedStages.clear(); saveProgress(); buildStageSelect(); };

            const buildStageSelect = () => {
                stageGrid.innerHTML = '';
                STAGES.forEach((_, index) => {
                    const btn = document.createElement('button');
                    btn.className = `stage-btn btn ${clearedStages.has(index) ? 'cleared' : ''}`;
                    btn.textContent = index + 1;
                    btn.onclick = () => goToGameScreen(index);
                    stageGrid.appendChild(btn);
                });
            };

            const loadStage = (stageId) => {
                currentStage = stageId;
                const stage = STAGES[stageId];
                stageTitle.textContent = `Stage ${stageId + 1}`;
                playerThreads = { vertical: Array(stage.size).fill(null), horizontal: Array(stage.size).fill(null) };
                setupGrid(goalGrid, stage.size, stage.goal, false);
                setupGrid(playerGrid, stage.size, null, true);
                setGamePhase('vertical');
                updatePlayerGrid();
            };
            
            const setGamePhase = (phase) => {
                gamePhase = phase;
                const isVerticalPhase = phase === 'vertical';
                
                verticalThreadGroup.classList.toggle('disabled', !isVerticalPhase);
                horizontalThreadGroup.classList.toggle('disabled', isVerticalPhase);
                confirmVerticalsBtn.classList.toggle('hidden', !isVerticalPhase);
                
                if (!isVerticalPhase) {
                    const size = STAGES[currentStage].size;
                    currentWeavingRow = size - 1; // Start from the bottom row
                }
                updateHighlightOverlay();
            };

            const setupGrid = (gridEl, size, cellColors, isPlayer) => {
                gridEl.innerHTML = '';
                gridEl.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
                const gridSize = `${Math.min(size * 60, 250)}px`;
                gridEl.style.width = gridSize;
                gridEl.style.height = gridSize;
                
                for (let i = 0; i < size * size; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    if (cellColors) cell.style.backgroundColor = COLOR_MAP[cellColors[i]] || 'transparent';
                    gridEl.appendChild(cell);
                }
                
                if(isPlayer) {
                    gridEl.insertAdjacentHTML('beforeend', '<div class="threads-overlay"></div><div class="highlight-overlay"></div>');
                }
            };
            
            const updatePlayerGrid = () => {
                const size = STAGES[currentStage].size;
                const cells = playerGrid.querySelectorAll('.grid-cell');
                const overlay = playerGrid.querySelector('.threads-overlay');
                overlay.innerHTML = '';
                
                for (let row = 0; row < size; row++) {
                    for (let col = 0; col < size; col++) {
                        const vThread = playerThreads.vertical[col];
                        const hThread = playerThreads.horizontal[row];
                        cells[row * size + col].style.backgroundColor = COLOR_MAP[mixColors(vThread, hThread)];
                    }
                }
                
                playerThreads.vertical.forEach((color, i) => { if (color) overlay.innerHTML += `<div class="thread vertical ${color}" style="left: ${((i + 0.5) / size) * 100}%"></div>`; });
                playerThreads.horizontal.forEach((color, i) => { if (color) overlay.innerHTML += `<div class="thread horizontal ${color}" style="top: ${((i + 0.5) / size) * 100}%"></div>`; });
                
                if(gamePhase === 'horizontal' && currentWeavingRow < 0) checkWinCondition();
            };

            const updateHighlightOverlay = () => {
                const overlay = playerGrid.querySelector('.highlight-overlay');
                if (gamePhase === 'horizontal' && currentWeavingRow >= 0) {
                    const size = STAGES[currentStage].size;
                    const rowHeight = 100 / size;
                    overlay.innerHTML = `<div class="highlight-row" style="height:${rowHeight}%; top:${currentWeavingRow * rowHeight}%"></div>`;
                } else {
                    overlay.innerHTML = '';
                }
            };

            const checkWinCondition = () => {
                const stage = STAGES[currentStage];
                if (stage.goal.every((goalColor, i) => {
                    const row = Math.floor(i / stage.size), col = i % stage.size;
                    return goalColor === mixColors(playerThreads.vertical[col], playerThreads.horizontal[row]);
                })) {
                    clearedStages.add(currentStage);
                    saveProgress();
                    setTimeout(() => showModal('クリア！', `ステージ ${currentStage + 1} をクリアしました！`, 'OK', goToStageSelectScreen), 300);
                }
            };

            const handleDrop = (e) => {
                e.preventDefault();
                if (!draggedThread || draggedThread.remove) { draggedThread = null; return; }

                const rect = playerGrid.getBoundingClientRect();
                const x = e.clientX - rect.left, y = e.clientY - rect.top;
                if (x < 0 || x > rect.width || y < 0 || y > rect.height) { draggedThread = null; return; }

                const size = STAGES[currentStage].size;
                const col = Math.floor(x / (rect.width / size));
                const row = Math.floor(y / (rect.height / size));

                if (gamePhase === 'vertical' && draggedThread.orientation === 'vertical') {
                    playerThreads.vertical[col] = draggedThread.color;
                } else if (gamePhase === 'horizontal' && draggedThread.orientation === 'horizontal' && row === currentWeavingRow) {
                    playerThreads.horizontal[row] = draggedThread.color;
                    currentWeavingRow--;
                    updateHighlightOverlay();
                }
                
                draggedThread = null;
                updatePlayerGrid();
            };

            const handleDragStartToRemove = (e) => {
                if (gamePhase !== 'vertical') return;
                const rect = playerGrid.getBoundingClientRect();
                const x = e.clientX - rect.left, y = e.clientY - rect.top;
                const size = STAGES[currentStage].size;
                const col = Math.floor(x / (rect.width / size));
                if (playerThreads.vertical[col]) {
                    draggedThread = { remove: true };
                    setTimeout(() => {
                        playerThreads.vertical[col] = null;
                        updatePlayerGrid();
                    }, 0);
                }
            };

            const showModal = (title, msg, confirmTxt, onConfirm, onCancel) => {
                modalTitle.textContent = title;
                modalMessage.textContent = msg;
                modalConfirm.textContent = confirmTxt;
                modalConfirm.onclick = () => { modalOverlay.classList.add('hidden'); onConfirm(); };
                modalCancel.classList.toggle('hidden', !onCancel);
                if (onCancel) modalCancel.onclick = () => { modalOverlay.classList.add('hidden'); onCancel(); };
                modalOverlay.classList.remove('hidden');
            };

            const showHint = () => {
                const { solution } = STAGES[currentStage];
                if (gamePhase === 'vertical') {
                    const incorrectV = solution.v.map((c, i) => (c !== playerThreads.vertical[i] ? i : -1)).filter(i => i !== -1);
                    if (incorrectV.length > 0) {
                        const idx = incorrectV[Math.floor(Math.random() * incorrectV.length)];
                        playerThreads.vertical[idx] = solution.v[idx];
                    }
                } else if (currentWeavingRow >= 0) {
                    playerThreads.horizontal[currentWeavingRow] = solution.h[currentWeavingRow];
                    currentWeavingRow--;
                    updateHighlightOverlay();
                }
                updatePlayerGrid();
            };

            // --- Event Listeners ---
            startGameBtn.onclick = goToStageSelectScreen;
            backToSelectBtn.onclick = goToStageSelectScreen;
            resetBtn.onclick = () => loadStage(currentStage);
            hintBtn.onclick = showHint;
            confirmVerticalsBtn.onclick = () => setGamePhase('horizontal');
            
            threadSelector.ondragstart = (e) => {
                if (e.target.classList.contains('draggable-thread')) {
                    draggedThread = { color: e.target.dataset.color, orientation: e.target.dataset.orientation };
                    e.dataTransfer.effectAllowed = 'move';
                }
            };
            playerGrid.ondragover = (e) => e.preventDefault();
            playerGrid.ondrop = handleDrop;
            playerGrid.ondragstart = handleDragStartToRemove;
            document.body.ondragend = () => draggedThread = null;

            settingsIcon.onclick = () => showModal('進捗のリセット', '本当に全てのステージのクリア状況をリセットしますか？', 'リセットする', resetProgress, () => {});
            modalOverlay.onclick = (e) => { if (e.target === modalOverlay) modalOverlay.classList.add('hidden'); };
            closeTutorialBtn.onclick = () => tutorialOverlay.classList.add('hidden');

            // --- Initialization ---
            const init = () => {
                STAGES.forEach(stage => stage.goal = generateGoalFromSolution(stage.solution, stage.size));
                loadProgress();
                showScreen(titleScreen);
            };

            init();
        });
    </script>
</body>
</html>

